= Algorithms and data structures

== Algorithms

The _how_ of programming.

== Data structures

The _what_ of programming.

== Solving any Sudoku

This function can solve any Sudoku.

It uses an algorithm called depth first search.

[source,python,numbers]
----
def solve(b):
    if b is None or solved(b): return b

    s = empty_square(b)
    for d in possible_digits(b, s):
        solution = solve(assign(b, s, d))
        if solution: return solution

    return None
----

== The helper functions

+solve+ is defined in terms of these functions that we will need to implement.

[source,python]
----
def solved(b): ...

def empty_square(b): ...

def possible_digits(b, s): ...

def assign(b, s, d): ...
----

== But what data structures?

In order to implement those functions, we need to decide how to represent the Sudoku board.

There are lots of possibilities.

== Representing a Sudoku

image:board-blank.svg[Sudoku board]

== Representing a Sudoku

image:board-numbers.svg[Sudoku board with numbers]

== List comprehensions

.Explicitly building a list
[source,python]
----
single = []
for r in range(9):
    single.append(r * 10)
----

.Using a list comprehension
[source,python]
----
single = [ r * 10 for r in range(9) ]
----

.Both build this list
[source,python]
----
[0, 10, 20, 30, 40, 50, 60, 70, 80]
----

== Nested loops

.Explicit
[source,python]
----
double = []
for x in (0, 3, 6):
    for y in (1, 4):
        double.append((x, y))
----

.Comprehension
[source,python]
----
double = [ (x, y) for x in (0, 3, 6) for y in (1, 4) ]
----

.Produces
[source,python]
----
[(0, 1), (0, 4), (3, 1), (3, 4), (6, 1), (6, 4)]
----

== Nested comprehensions

.Explicit
[source,python]
----
nested = []
for i in range(10):
    inner = []
    for x in range(i):
        inner.append(x * 10)
    nested.append(inner)
----

.Comprehension
[source,python]
----
nested = [ [ x * 10 for x in range(i) ] for i in range(10) ]
----

.Produces
[source,python]
----
[[], [0], [0, 10], [0, 10, 20], [0, 10, 20, 30], [0, 10, 20, 30, 40], [0, 10, 20, 30, 40, 50], [0, 10, 20, 30, 40, 50, 60], [0, 10, 20, 30, 40, 50, 60, 70], [0, 10, 20, 30, 40, 50, 60, 70, 80]]
----

== Some useful lists of indices

[source,python]
----
rows  = [[ r*9 + c for c in range(9) ] for r in range(9) ]
cols  = [[ r*9 + c for r in range(9) ] for c in range(9) ]
boxes = [[ r*9 + c for r in range(x, x+3) for c in range(y, y+3) ]
            for x in range(0, 9, 3) for y in range(0, 9, 3) ]
----


== Some more useful lists of indices

'Units' are what we'll call rows, columns, and boxes.

The 'peers' of a square are all the squares that share a unit.


[source,python]
----
units = [[ u for u in (rows + cols + boxes) if s in u ]
           for s in range(81) ]
peers = [ set(sum(units[s], [])) - {s} for s in range(81) ]
----
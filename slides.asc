= Algorithms and data structures

== Algorithms

The _how_ of programming.

== Data structures

The _what_ of programming.

== Solving any Sudoku

This function can solve any Sudoku.

It uses an algorithm called depth first search.

[source,python,numbers]
----
def solve(b):
    if b is None or solved(b): return b

    s = empty_square(b)
    for d in possible_digits(b, s):
        solution = solve(assign(b, s, d))
        if solution: return solution

    return None
----

== The helper functions

+solve+ is defined in terms of these functions that we will need to
implement. That's where the data structures will come in.

[source,python]
----
def solved(b): ...

def empty_square(b): ...

def possible_digits(b, s): ...

def assign(b, s, d): ...
----

== But what data structures?

In order to implement those functions, we need to decide how to represent the Sudoku board.

There are lots of possibilities.

== A digression

List comprehensions, a super cool feature of Python.

== Simple list comprehension

.Explicitly building a list
[source,python]
----
single = []
for r in range(9):
    single.append(r * 10)
----

.Using a list comprehension
[source,python]
----
single = [ r * 10 for r in range(9) ]
----

.Both build this list
[source,python]
----
[0, 10, 20, 30, 40, 50, 60, 70, 80]
----

== Nested loops

.Explicit
[source,python]
----
double = []
for x in (0, 3, 6):
    for y in (1, 4):
        double.append((x, y))
----

.Comprehension
[source,python]
----
double = [ (x, y) for x in (0, 3, 6) for y in (1, 4) ]
----

.Produces
[source,python]
----
[(0, 1), (0, 4), (3, 1), (3, 4), (6, 1), (6, 4)]
----

== Nested comprehensions

.Explicit
[source,python]
----
outer = []
for i in range(10):
    inner = []
    for x in range(i):
        inner.append(x * 10)
    outer.append(inner)
----

.Comprehension
[source,python]
----
outer = [ [ x * 10 for x in range(i) ] for i in range(10) ]
----

.Produces
[source,python]
----
[[], [0], [0, 10], [0, 10, 20], [0, 10, 20, 30], [0, 10, 20, 30, 40], [0, 10, 20, 30, 40, 50], [0, 10, 20, 30, 40, 50, 60], [0, 10, 20, 30, 40, 50, 60, 70], [0, 10, 20, 30, 40, 50, 60, 70, 80]]
----

== Now back to your regularly scheduled Sudoku programming

== Representing a Sudoku

image:board-blank.svg[Sudoku board]

== Representing a Sudoku

image:board-numbers.svg[Sudoku board with numbers]

== Parsing a string into a board data structure

[source,python]
----
digits  = set('123456789')
squares = range(81)

def is_square_char(c): return c in digits or c == '.'

def given(c): return c if c in digits else None

def board(text):
    return [ given(c) for c in text if is_square_char(c) ]
----

== +board+ in action

.Input
[source,python]
----
'.5...1479..27....8....462...46..9537....6....8935..64...961....1....23..3274...1.'
----

.Returns
[source,python]
----
[None, '5', None, None, None, '1', '4', '7', '9', None, None, '2', '7', None, None, None, None, '8', None, None, None, None, '4', '6', '2', None, None, None, '4', '6', None, None, '9', '5', '3', '7', None, None, None, None, '6', None, None, None, None, '8', '9', '3', '5', None, None, '6', '4', None, None, None, '9', '6', '1', None, None, None, None, '1', None, None, None, None, '2', '3', None, None, '3', '2', '7', '4', None, None, None, '1', None]
----

That last thing is the data structure we're using: a simple list.

== Can also grok this

[source,python]
----
puzzle = '''
. 5 . | . . 1 | 4 7 9
. . 2 | 7 . . | . . 8
. . . | . 4 6 | 2 . .
------+-------+------
. 4 6 | . . 9 | 5 3 7
. . . | . 6 . | . . .
8 9 3 | 5 . . | 6 4 .
------+-------+------
. . 9 | 6 1 . | . . .
1 . . | . . 2 | 3 . .
3 2 7 | 4 . . | . 1 .
'''
----

== Some useful lists of indices

[source,python]
----
rows  = [[ r*9 + c for c in range(9) ] for r in range(9) ]
cols  = [[ r*9 + c for r in range(9) ] for c in range(9) ]
boxes = [[ r*9 + c for r in range(x, x+3) for c in range(y, y+3) ]
            for x in range(0, 9, 3) for y in range(0, 9, 3) ]
----

== Printing a board

[source,python]
----
divider = '\n------+-------+------\n'

def sq(x): return x if x is not None else '.'

def row_chunk(b, r, c):
    return ' '.join(sq(b[s]) for s in rows[r][c:c+3])

def row(b, r):
    return ' | '.join(row_chunk(b, r, c) for c in (0, 3, 6))

def band(b, i):
    return '\n'.join(row(b, r) for r in range(i * 3, (i+1) * 3))

def grid(b): return divider.join(band(b, i) for i in range(3))

def oneline(b): return ''.join(sq(x) for x in b)
----

== Output

.Grid output
----
. 5 . | . . 1 | 4 7 9
. . 2 | 7 . . | . . 8
. . . | . 4 6 | 2 . .
------+-------+------
. 4 6 | . . 9 | 5 3 7
. . . | . 6 . | . . .
8 9 3 | 5 . . | 6 4 .
------+-------+------
. . 9 | 6 1 . | . . .
1 . . | . . 2 | 3 . .
3 2 7 | 4 . . | . 1 .
----

.One-line output
----
.5...1479..27....8....462...46..9537....6....8935..64...961....1....23..3274...1.
----

== Implement helpers

[source,python]
----
def solved(b): return not any(s is None for s in b)

def empty_square(b):
    try:
        return b.index(None)
    except:
        return None

def possible_digits(b, s): return digits

def assign(b, s, d): ...
----

== Units and peers

Each square belongs to three 'units': a row, column, and box.

The 'peers' of a square are all the squares that share a unit.

[source,python]
----
units = [ [ u for u in (rows + cols + boxes) if s in u ]
          for s in squares ]

peers = [ set(sum(units[s], [])) - {s} for s in squares ]
----

== Implement +assign+

The only tricky bit is making sure we return +None+ when the
assignment leads to a contradiction.

[source,python]
----
def assign(b, s, d):
    new_board = b.copy() # keep things side-effect free
    new_board[s] = d
    return new_board if not contradiction(new_board) else None

def contradiction(b):
    return not all(okay(b, s) for s in squares if b[s] is not None)

def okay(b, s):
    return not any(b[s] == b[p] for p in peers[s])
----

== Make a program out of it

[source,python]
----
if __name__ == '__main__':

    def side_by_side(g1, g2, space=10):
        for l1, l2 in zip(g1.split('\n'), g2.split('\n')):
            print(l1 + (' ' * space) + l2)

    import fileinput
    puzzle = ''.join(fileinput.input())
    side_by_side(grid(board(puzzle)), grid(solve(board(puzzle))))
----

== Can solve any Sudoku

But it's slow for harder puzzles.

The problem is the space to search can be humongously large and the
contradictions may not show up right away.

== An easy puzzle

----
$ time ./sudoku.py easy.txt
. 5 . | . . 1 | 4 7 9          6 5 8 | 2 3 1 | 4 7 9
. . 2 | 7 . . | . . 8          4 3 2 | 7 9 5 | 1 6 8
. . . | . 4 6 | 2 . .          9 7 1 | 8 4 6 | 2 5 3
------+-------+------          ------+-------+------
. 4 6 | . . 9 | 5 3 7          2 4 6 | 1 8 9 | 5 3 7
. . . | . 6 . | . . .          7 1 5 | 3 6 4 | 8 9 2
8 9 3 | 5 . . | 6 4 .          8 9 3 | 5 2 7 | 6 4 1
------+-------+------          ------+-------+------
. . 9 | 6 1 . | . . .          5 8 9 | 6 1 3 | 7 2 4
1 . . | . . 2 | 3 . .          1 6 4 | 9 7 2 | 3 8 5
3 2 7 | 4 . . | . 1 .          3 2 7 | 4 5 8 | 9 1 6

real	0m0.096s
user	0m0.085s
sys	0m0.008s
----

== A harder puzzle

----
$ time ./sudoku.py hard.txt
8 5 . | . . 2 | 4 . .          8 5 9 | 6 1 2 | 4 3 7
7 2 . | . . . | . . 9          7 2 3 | 8 5 4 | 1 6 9
. . 4 | . . . | . . .          1 6 4 | 3 7 9 | 5 2 8
------+-------+------          ------+-------+------
. . . | 1 . 7 | . . 2          9 8 6 | 1 4 7 | 3 5 2
3 . 5 | . . . | 9 . .          3 7 5 | 2 6 8 | 9 1 4
. 4 . | . . . | . . .          2 4 1 | 5 9 3 | 7 8 6
------+-------+------          ------+-------+------
. . . | . 8 . | . 7 .          4 3 2 | 9 8 1 | 6 7 5
. 1 7 | . . . | . . .          6 1 7 | 4 2 5 | 8 9 3
. . . | . 3 6 | . 4 .          5 9 8 | 7 3 6 | 2 4 1

real	4m46.434s
user	4m46.274s
sys	0m0.101s
----

== Easy algorithmic speed up

Avoid searching digits that we immediately know can't work.

[source,python]
----
def possible_digits(b, s):
    return [ d for d in digits if legal_digit(b, s, d) ]

def legal_digit(b, s, d):
    return not any(b[p] == d for p in peers[s])
----

== Faster

----
$ time ./sudoku.py hard.txt
8 5 . | . . 2 | 4 . .          8 5 9 | 6 1 2 | 4 3 7
7 2 . | . . . | . . 9          7 2 3 | 8 5 4 | 1 6 9
. . 4 | . . . | . 2 .          1 6 4 | 3 7 9 | 5 2 8
------+-------+------          ------+-------+------
. . . | 1 4 7 | . . 2          9 8 6 | 1 4 7 | 3 5 2
3 7 5 | . . 8 | 9 1 4          3 7 5 | 2 6 8 | 9 1 4
. 4 . | . . . | . . .          2 4 1 | 5 9 3 | 7 8 6
------+-------+------          ------+-------+------
4 . . | 9 8 1 | . 7 .          4 3 2 | 9 8 1 | 6 7 5
. 1 7 | . . . | . 9 .          6 1 7 | 4 2 5 | 8 9 3
. . . | 7 3 6 | . 4 .          5 9 8 | 7 3 6 | 2 4 1

real	0m1.063s
user	0m1.053s
sys	0m0.007s
----


== Let's make it faster yet.

We'll use a better data structure.

[source,python]
----
def givens(text):
    return [ given(c) for c in text if is_square_char(c) ]

def board(text):
    b = [ set(digits) for _ in squares ]
    for s, d in enumerate(givens(text)):
        if d and not set_digit(b, s, d): return None
    return b

def set_digit(b, s, d): ...
----

== A few fixups

[source,python]
----
def sq(x): return '.' if x is None or len(x) > 1 else list(x)[0]

def solved(b): return all(len(s) == 1 for s in b)

def empty_square(b):
    def size(s): return len(b[s])
    return min((s for s in squares if size(s) > 1), key=size)

def possible_digits(b, s): return b[s]

def assign(b, s, d):
    new_board = [ s.copy() for s in b ]
    return new_board if set_digit(new_board, s, d) else None
----

== But to make it really fast ...

We need an even better algorithm: constraint propagation.

[source,python]
----
def set_digit(b, s, d):
    return all(eliminate_digit(b, s, d2) for d2 in b[s] - {d})

def eliminate_digit(b, s, d):
    if d in b[s]:
        b[s].remove(d)
        if not propagate_assignment(b, s): return False
        if not propagate_to_unit(b, s, d): return False
    return True

def propagate_assignment(b, s): ...

def propagate_to_unit(b, s, d): ...
----

== Implicit assignment

When a square has been reduced to a single digit, we can eliminate
that digit from all the square's peers.

[source,python]
----
def propagate_assignment(b, s):
    if len(b[s]) == 1:
        d2 = list(b[s])[0]
        for p in peers[s]:
            if not eliminate_digit(b, p, d2): return False
    return True
----

== Check our units

Check each of the square's units to see if some other square is now
the only place for the digit we just eliminated.

[source,python]
----
def propagate_to_unit(b, s, d):
    for u in units[s]:
        places = [ s2 for s2 in u if d in b[s2] ]
        if len(places) == 0:
            # Ooops, we just eliminated the last possible place.
            return False
        elif len(places) == 1:
            if not set_digit(b, places[0], d): return False
    return True
----

== Now nice and fast!

----
$ time ./sudoku.py hard.txt
8 5 . | . . 2 | 4 . .          8 5 9 | 6 1 2 | 4 3 7
7 2 . | . . . | . . 9          7 2 3 | 8 5 4 | 1 6 9
. . 4 | . . . | . . .          1 6 4 | 3 7 9 | 5 2 8
------+-------+------          ------+-------+------
. . . | 1 . 7 | . . 2          9 8 6 | 1 4 7 | 3 5 2
3 . 5 | . . . | 9 . .          3 7 5 | 2 6 8 | 9 1 4
. 4 . | . . . | . . .          2 4 1 | 5 9 3 | 7 8 6
------+-------+------          ------+-------+------
. . . | . 8 . | . 7 .          4 3 2 | 9 8 1 | 6 7 5
. 1 7 | . . . | . . .          6 1 7 | 4 2 5 | 8 9 3
. . . | . 3 6 | . 4 .          5 9 8 | 7 3 6 | 2 4 1

real	0m0.043s
user	0m0.033s
sys	0m0.008s
----
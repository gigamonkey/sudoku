= Algorithms and data structures

== Algorithms

The _how_ of programming.

== Data structures

The _what_ of programming.

== Solving any Sudoku

This function can solve any Sudoku.

It uses an algorithm called depth first search.

[source,python,numbers]
----
def solve(b):
    if b is None or solved(b): return b

    s = empty_square(b)
    for d in possible_digits(b, s):
        solution = solve(assign(b, s, d))
        if solution: return solution

    return None
----

== The helper functions

+solve+ is defined in terms of these functions that we will need to implement.

[source,python]
----
def solved(b): ...

def empty_square(b): ...

def possible_digits(b, s): ...

def assign(b, s, d): ...
----

== But what data structures?

In order to implement those functions, we need to decide how to represent the Sudoku board.

There are lots of possibilities.

== Representing a Sudoku

image:board-blank.svg[Sudoku board]

== Representing a Sudoku

image:board-numbers.svg[Sudoku board with numbers]

== List comprehensions

.Explicitly building a list
[source,python]
----
single = []
for r in range(9):
    single.append(r * 10)
----

.Using a list comprehension
[source,python]
----
single = [ r * 10 for r in range(9) ]
----

.Both build this list
[source,python]
----
[0, 10, 20, 30, 40, 50, 60, 70, 80]
----

== Nested loops

.Explicit
[source,python]
----
double = []
for x in (0, 3, 6):
    for y in (1, 4):
        double.append((x, y))
----

.Comprehension
[source,python]
----
double = [ (x, y) for x in (0, 3, 6) for y in (1, 4) ]
----

.Produces
[source,python]
----
[(0, 1), (0, 4), (3, 1), (3, 4), (6, 1), (6, 4)]
----

== Nested comprehensions

.Explicit
[source,python]
----
nested = []
for i in range(10):
    inner = []
    for x in range(i):
        inner.append(x * 10)
    nested.append(inner)
----

.Comprehension
[source,python]
----
nested = [ [ x * 10 for x in range(i) ] for i in range(10) ]
----

.Produces
[source,python]
----
[[], [0], [0, 10], [0, 10, 20], [0, 10, 20, 30], [0, 10, 20, 30, 40], [0, 10, 20, 30, 40, 50], [0, 10, 20, 30, 40, 50, 60], [0, 10, 20, 30, 40, 50, 60, 70], [0, 10, 20, 30, 40, 50, 60, 70, 80]]
----

== Parsing a string into a board data structure

[source,python]
----
digits  = set('123456789')
squares = range(81)

def is_square_char(c): return c in digits or c == '.'

def to_given(c): return None if c == '.' else c

def board(text):
    return [ to_given(c) for c in text if is_square_char(c) ]
----

== board in action

.Input
[source,python]
----
'.5...1479..27....8....462...46..9537....6....8935..64...961....1....23..3274...1.'
----

.Returns
[source,python]
----
[None, '5', None, None, None, '1', '4', '7', '9', None, None, '2', '7', None, None, None, None, '8', None, None, None, None, '4', '6', '2', None, None, None, '4', '6', None, None, '9', '5', '3', '7', None, None, None, None, '6', None, None, None, None, '8', '9', '3', '5', None, None, '6', '4', None, None, None, '9', '6', '1', None, None, None, None, '1', None, None, None, None, '2', '3', None, None, '3', '2', '7', '4', None, None, None, '1', None]
----

== Some useful lists of indices

[source,python]
----
rows  = [[ r*9 + c for c in range(9) ] for r in range(9) ]
cols  = [[ r*9 + c for r in range(9) ] for c in range(9) ]
boxes = [[ r*9 + c for r in range(x, x+3) for c in range(y, y+3) ]
            for x in range(0, 9, 3) for y in range(0, 9, 3) ]
----

== Printing a board

[source,python]
----
def sq(x): return x if x is not None else '.'

def row_chunk(b, r, c):
    return ' '.join(sq(b[s]) for s in rows[r][c:c+3])

def row(b, r):
    return ' | '.join(row_chunk(b, r, c) for c in (0, 3, 6))

def band(b, i):
    return '\n'.join(row(b, r) for r in range(i * 3, (i+1) * 3))

divider = '\n------+-------+------\n'

def grid(b): return divider.join(band(b, i) for i in range(3))

def oneline(b): return ''.join(sq(x) for x in b)
----

== Output

.Grid output
----
. 5 . | . . 1 | 4 7 9
. . 2 | 7 . . | . . 8
. . . | . 4 6 | 2 . .
------+-------+------
. 4 6 | . . 9 | 5 3 7
. . . | . 6 . | . . .
8 9 3 | 5 . . | 6 4 .
------+-------+------
. . 9 | 6 1 . | . . .
1 . . | . . 2 | 3 . .
3 2 7 | 4 . . | . 1 .
----

.One-line output
----
.5...1479..27....8....462...46..9537....6....8935..64...961....1....23..3274...1.
----

== Implement helpers

[source,python]
----
def solved(b): return not any(s is None for s in b)

def empty_square(b):
    try:
        return b.index(None)
    except:
        return None

def possible_digits(b, s): return digits
----

== Units and peers

'Units' are what we'll call rows, columns, and boxes.

The 'peers' of a square are all the squares that share a unit.


[source,python]
----
units = [ [ u for u in (rows + cols + boxes) if s in u ]
          for s in squares ]
peers = [ set(sum(units[s], [])) - {s} for s in squares ]
----

== Implement 'assign'

[source,python]
----
def assign(b, s, d):
    new_board = b.copy()
    new_board[s] = d
    return new_board if not contradiction(new_board) else None

def contradiction(b):
    return not all(okay(b, s) for s in squares if b[s] is not None)

def okay(b, s):
    return not any(b[s] == b[p] for p in peers[s])
----
